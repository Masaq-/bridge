#!/usr/bin/ruby
# vim: noai:ts=4:sw=4
#
#  Copyright (C) 2010-2017 by Luiz Angelo Daros de Luca
#    luizluca@gmail.com
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    Created on 2010-08-10
#
# Changelog:
#
# * 2017-03-17
# - Add support for http proxy authentication using auto-detect support
#
# * 2010-09-01
# - Add TCP keepalive flags for local socket (thanks Jan Ad√°mek)
# - Increased local buffer to 640k
# - Fixed sync problem with stdin/out when using as ProxyCommand inside ssh config
# - Reconnection on client-webrick disconnection
# - Fixed proxy absence
# - Specified webrick timeout (10m)
# - Treated more signals
# - Divide connection (open, read, write)
#
#
#################
#
# Port Forward client/server over HTTP
#
#################

class String
    def strip_heredoc
        min = scan(/^[ \t]*(?=\S)/).min
        if min == nil
            indent=0
        else
            indent=min.size
        end
        gsub(/^[ \t]{#{indent}}/, '')
    end
end

case ARGV.size
    when 2
        server=true
        location=ARGV[1]
     when 4
        server=false
        url=ARGV[1]
        remote_host=ARGV[2]
        remote_port=ARGV[3].to_i
    else
    $stderr.puts <<-EOF.strip_heredoc
	Use as server:
	#$0 localPort bridgeLocation
	
	Use as client:
	#$0 localPort|STDIN bridgeURL remoteAddress remotePort
	
	Ex:
	bridge$ #$0 8080 /bridge
	
	client$ #$0 8022 http://mybridge:8080/bridge remoteServer 22
	client$ ssh localhost -p 8022
	EOF
    exit
end

localPort=ARGV[0]

require 'socket'
require 'thread'
Thread.abort_on_exception = true

MAXBUF=1024*640 # 640k
READ_TIMEOUT=60
CLIENT_MAX_CONNECTIONS=32
CLIENT_PENDING_CONNECTIONS=6
if server
    require 'webrick'

    class BridgeServlet < WEBrick::HTTPServlet::AbstractServlet
        @@connections = {}

        def get_socket(req,res)
            conn_id = req.path.split("/").last
            conn = @@connections[conn_id]
            if not conn
                $stderr.puts "[#{conn_id}] Connection is not open for #{conn_id}=#{conn}"
                res.status=404
                return nil
            end
            conn
        end

        def close_socket(req,res)
            conn_id = req.path.split("/").last
            return if not conn=@@connections[conn_id]
            conn.close if not conn.closed?
            @@connections.delete(conn_id)
        end

        def do_POST(req, res)
            conn_id = req.path.split("/").last
            (remote_host,remote_port)=req.body.split(":")
            remote_port=remote_port.to_i
            $stderr.puts "[#{conn_id}] Opening connection to #{remote_host}:#{remote_port} for #{req.peeraddr}..."
            begin
                conn=TCPSocket.open(remote_host,remote_port)
                conn.setsockopt(Socket::SOL_SOCKET, Socket::SO_KEEPALIVE, true)
                @@connections[conn_id]=conn
                $stderr.puts "[#{conn_id}] Connected to #{remote_host}:#{remote_port} #{conn}"
                res.status=201
            rescue Errno::EMFILE
                $stderr.puts "[#{conn_id}] Connection failed: #$!"
                @@connections.delete_if do |conn_id, conn|
                    conn.close if not conn.closed?
                    $stderr.puts "[#{conn_id}] Connection closed for #{conn_id}=#{conn}"
                    true
                end
                res['Content-Type'] = "text/plain"
                res.body=$!.message
                res.status=503 # Service Unavailable
            rescue
                res['Content-Type'] = "text/plain"
                res.body=$!.message
                $stderr.puts "[#{conn_id}] Connection failed: #$!"
                res.status=406 # Not Acceptable
            end
        end

        def do_PUT(req, res)
            conn_id = req.path.split("/").last
            return if not s=get_socket(req,res)
            begin
                s.print req.body
            rescue Errno::EPIPE, IOError
                $stderr.puts "[#{conn_id}] Connection closed in remote destination (PUT)"
                close_socket(req, res)
                res.status=410 # GONE
            end
        end

        def do_GET(req, res)
            conn_id = req.path.split("/").last
            return if not conn=get_socket(req,res)
            begin
                res.body = conn.read_nonblock(MAXBUF)
            rescue IO::WaitReadable
                if IO.select([conn],[],[],READ_TIMEOUT-3)
                    retry
                else # Timeout
                    res.body = ''
                    res.status=204 # No Content
                end
            rescue EOFError, Errno::EPIPE, IOError
                if conn.closed?
                    $stderr.puts "[#{conn_id}] Connection closed by remote destination (GET)"
                else
                    $stderr.puts "[#{conn_id}] Connection closed (GET) #{$!}"
                end
                close_socket(req, res)
                res.status=410 # Gone
            rescue
                $stderr.puts $!.class
            end
        end

        def do_DELETE(req, res)
            conn_id = req.path.split("/").last
            $stderr.puts "[#{conn_id}] Connection closed in client. Trying to close it in remote destination"
            close_socket(req, res)
            res.status=200
        end

    end

    s = WEBrick::HTTPServer.new(
        :Port            => localPort.to_i,
        :RequestTimeout  => 600
    )
    s.mount(location, BridgeServlet)
    trap("INT"){ s.shutdown }
    s.start

else # Client

    output=Queue.new
    output_thread=Thread.new do
        loop do
            $stderr.puts output.pop
        end
    end

    require "net/http"
    require 'uri'

    # HACK! https://bugs.ruby-lang.org/issues/12921
    class Net::HTTP
        def proxy_user
          if @proxy_from_env then
            proxy_uri && proxy_uri.user
          else
            @proxy_user
          end
        end
        def proxy_pass
          if @proxy_from_env then
            proxy_uri && proxy_uri.password
          else
            @proxy_pass
          end
        end
    end

    url = URI(url)
    if url.find_proxy
        output.push "Using proxy: #{url.find_proxy}".freeze
    end

    case localPort
    when "STDIN".freeze,"-".freeze
        _in=$stdin
        _out=$stdout
    else
        output.push "Opening local port #{localPort}".freeze
        local_server = Socket.new(:INET, :STREAM, 0)
        local_server.bind Addrinfo.tcp("127.0.0.1".freeze, localPort.to_i)
        local_server.listen CLIENT_PENDING_CONNECTIONS
        Thread.abort_on_exception = false
    end

    lwrr=ThreadGroup.new
    lrrw=ThreadGroup.new
    random=Random.new

loop do

    case localPort
    when "STDIN".freeze,"-".freeze
        # Keeps this unbuffered
        _in.sync=true
        _out.sync=true
    else
        output.push "Waiting for local connection to port #{localPort}".freeze
        local_server_conn = nil
        loop do
            begin
                if IO.select([local_server],[],[],READ_TIMEOUT+3)
                    if lwrr.list.size < CLIENT_MAX_CONNECTIONS and lrrw.list.size < CLIENT_MAX_CONNECTIONS
                        local_server_conn, addrinfo = local_server.accept_nonblock
                        break
                    else
                        output.push "Too many local connections (limit #{CLIENT_MAX_CONNECTIONS})".freeze
                        sleep 1
                    end
                end
            rescue
                output.push "Still waiting for local connection to port #{localPort}".freeze
                retry
            end
        end
        # Keep connection alive
        local_server_conn.setsockopt(Socket::SOL_SOCKET, Socket::SO_KEEPALIVE, true)
        _in=_out=local_server_conn
    end

    #unique Connection IDentifier
    uuid=random.bytes(16).unpack("NnnnnN".freeze)
    uuid[2]=(uuid[2] & 0x0fff) | 0x4000
    uuid[3]=(uuid[3] & 0x3fff) | 0x8000
    uuid=("%08x-%04x-%04x-%04x-%04x%08x".freeze % uuid).freeze

lrrw.add(client_thread=Thread.new(_in,_out,uuid) do |_in,_out,conn_id| begin
    output.push "\nThread started".freeze

    conn_id.freeze
    connected=false
    # Open the connection
    http=nil
    begin
        begin
            output.push "Opening connection over HTTP bridge for #{remote_host}:#{remote_port} (#{conn_id})".freeze
            # HACK! new().start() because of https://bugs.ruby-lang.org/issues/13351
            http=Net::HTTP.new(url.host, url.port).start
            begin
                res = http.post("#{url.path}/#{conn_id}".freeze,"#{remote_host}:#{remote_port}".freeze).freeze
                if res.kind_of? Net::HTTPCreated
                    connected=true
                else
                    output.push "The bridge failed to connect to the remote location (#{res}): #{res.body}".freeze
                    connected=false
                end
            end
        rescue Errno::EPIPE
            output.push "Connection to bridge #{url} closed".freeze
            retry
        end

        # Not connected, nothing more to do
        Thread.current.exit if not connected

        # Launch Local write/Remote read loop
        lwrr.add(Thread.new(_in,_out) do |_in,_out|
            begin
                output.push "Local write/Remote read loop started".freeze
                output.push " #{lwrr.list.size} (lw/rr) #{lrrw.list.size} (lr/rw) threads ".freeze
                Net::HTTP.new(url.host, url.port).start do |http|
                    http.read_timeout=READ_TIMEOUT+3
                    while connected
                        res = http.get("#{url.path}/#{conn_id}".freeze).freeze
                        if res.kind_of? Net::HTTPOK
                            _out.print res.body
                        elsif res.kind_of? Net::HTTPGone
                            output.push "Connection closed in remote location (lw/rr)".freeze
                            connected=false
                            _in.close if not _in.closed?
                            break
                        elsif res.kind_of? Net::HTTPNotFound
                            output.push "Connection not opened on bridge".freeze
                            connected=false
                            break
                        end
                    end
                end
            rescue Errno::EPIPE
                _in.close if not _in.closed?
            rescue EOFError
                # retry if local connection is still open
                retry if not _in.closed?
                output.push "Connection to bridge closed (lw/rr)".freeze
            rescue Errno::ECONNREFUSED
                output.push "Connection to bridge failed (lw/rr)".freeze
                _in.close if not _in.closed?
            rescue Timeout::Error
                output.push "Timeout (lw/rr)".freeze
                retry if not _in.closed?
            rescue Net::ReadTimeout
                output.push "Net::ReadTimeout (lw/rr)".freeze
                retry if not _in.closed?
            rescue Net::HTTPServerError
                raise res.message
            ensure
                output.push " #{lwrr.list.size-1} (lw/rr) #{lrrw.list.size} (lr/rw) threads ".freeze
                _in.close if not _in.closed?
            end
        end)

        # If CTRL+C, SIGHUP or SIGTERM, close _in (and itself)
        trap("INT".freeze){ _in.close if not _in.closed? }
        trap("SIGHUP".freeze){ _in.close if not _in.closed? }
        trap("SIGTERM".freeze){ _in.close if not _in.closed? }

        # Launch "Local read/Remote write loop started".freeze
        output.push "Local read/Remote write loop started".freeze
        output.push " #{lwrr.list.size} (lw/rr) #{lrrw.list.size} (lr/rw) threads ".freeze
        # Keep buffer between retries
        buf=nil
        begin
            begin
                while connected
                    begin
                        # first read from _in ONLY if buf is empty
                        buf=_in.read_nonblock(MAXBUF).freeze if !buf
                    rescue IO::WaitReadable
                        IO.select([_in],[],[],READ_TIMEOUT+3)
                        retry
                    rescue EOFError
                        output.push "Local connection closed (lr/rw)".freeze
                        output.push "Closing bridge connection to remote location".freeze
                        http.delete("#{url.path}/#{conn_id}".freeze)
                        connected=false
                        break
                    end

                    res = http.put("#{url.path}/#{conn_id}".freeze,buf).freeze
                    if res.kind_of? Net::HTTPGone
                        output.push "Connection closed in remote location (lr/rw)".freeze
                        _in.close if not _in.closed?
                        connected=false
                        break
                    end

                    # Buffer sent, clear it
                    buf=nil
                end
            end
        rescue Net::ReadTimeout
            output.push "Net::ReadTimeout (lr/rw)".freeze
            retry if not _in.closed? and connected
        rescue Net::HTTPServerError
            raise "Server said: '#{res.message}'".freeze
        rescue Errno::EPIPE, IOError
            # retry if local connection is still open
            retry if not _in.closed?
            output.push "Connection to bridge closed (lr/rw)".freeze
        end
    rescue Errno::ECONNREFUSED
        output.push "Connection to bridge failed".freeze
    ensure
        http.finish
    end
    output.push "Thread Finished!".freeze
    ensure
        output.push " #{lwrr.list.size} (lw/rr) #{lrrw.list.size-1} (lr/rw) threads ".freeze
        _in.close if not _in.closed?
    end
end)
    case localPort
    when "STDIN".freeze,"-".freeze
        client_thread.join if client_thread.alive?
        break
    else
        client_thread.wakeup if client_thread.alive?
    end
end
output.push "\n".freeze
output_thread.run until output.empty?
output_thread.exit
end

$stderr.puts "Program Finished!"
